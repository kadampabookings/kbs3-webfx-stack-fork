package dev.webfx.stack.session.state.server;

import dev.webfx.platform.async.Future;
import dev.webfx.platform.console.Console;
import dev.webfx.stack.session.Session;
import dev.webfx.stack.session.SessionService;
import dev.webfx.stack.session.state.SessionAccessor;
import dev.webfx.stack.session.state.StateAccessor;

/**
 * @author Bruno Salmon
 */
public final class ServerSideStateSessionSyncer {

    // ======================================== INCOMING STATE ON SERVER ========================================
    // Sync methods to be used on server side, when the server receives an incoming state from a client

    public static Future<Boolean> syncServerSessionFromIncomingClientState(Session serverSession, Object clientState, boolean forceSessionStorage) {
        // serverSession.id <= clientState.sessionId ? NEVER, because this is the server session that is responsible for the session id
        // serverSession.userId <= clientState.userId ? YES IF SET, as this means the client switched user, so we memorise that info in the session
        boolean userIdChanged = SessionAccessor.changeUserId(serverSession, StateAccessor.getUserId(clientState), true);
        // serverSession.runId <= clientState.runId ? YES IF SET, as this means the client is communicating the run id, so we memorise that in the session
        String runId = StateAccessor.getRunId(clientState);
        boolean runIdChanged = SessionAccessor.changeRunId(serverSession, runId, true);
        // Since clients communicate the runId on first connection or reconnection, the sessionId must be synced in both cases (on reconnection, the session id may have changed)
        boolean sessionIdSyncedChanged = runId != null && SessionAccessor.changeSessionIdSynced(serverSession, false);
        if (userIdChanged || runIdChanged || sessionIdSyncedChanged || forceSessionStorage)
            return storeServerSession(serverSession);
        return Future.succeededFuture(null);
    }

    private static Future<Boolean> storeServerSession(Session serverSession) {
        Future<Boolean> future = SessionService.getSessionStore().put(serverSession);
        future.onFailure(Console::log);
        return future;
    }

    public static Object syncIncomingClientStateFromServerSession(Object clientState, Session serverSession) {
        // clientState.sessionId <= serverSession.id ? ALWAYS, because this is the server session that is responsible for the session id
        clientState = StateAccessor.setSessionId(clientState, serverSession.id(), true);
        // clientState.userId <= serverSession.userId ? YES IF NOT SET, otherwise this means the client switched user, so we keep that info
        clientState = StateAccessor.setUserId(clientState, SessionAccessor.getUserId(serverSession), false);
        // clientState.runId <= serverSession.runId ? YES IF NOT SET, otherwise this means the client communicates it, so we keep that info
        clientState = StateAccessor.setRunId(clientState, SessionAccessor.getRunId(serverSession), false);
        return clientState;
    }


    // ======================================== OUTGOING STATE ON SERVER ========================================
    // Sync methods to be used on server side, when the server is about to send a state generated by the server back to the client

    public static Object syncOutgoingServerStateFromServerSessionAndViceVersa(Object serverState, Session serverSession) {
        // serverSession.id <= serverState.sessionId ? NO (doesn't make sense, serverSession.id can't be changed)
        // serverSession.userId <= serverState.userId ? YES IF SET, as this means the server switched or logged-in user, so we memorise that info in the session
        boolean userIdChanged = SessionAccessor.changeUserId(serverSession, StateAccessor.getUserId(serverState), true);
        // serverSession.runId <= serverState.runId ? NEVER, because this is info can only come from an incoming serverState.
        // serverState.sessionId <= serverSession.id ? ONLY if the client doesn't know it already
        boolean sessionIdSyncedChanged = false;
        if (!SessionAccessor.isSessionIdSynced(serverSession)) {
            serverState = StateAccessor.setSessionId(serverState, serverSession.id(), true);
            sessionIdSyncedChanged = SessionAccessor.changeSessionIdSynced(serverSession, true);
        }
        // serverState.userId <= serverSession.userId ? NO, we communicate this info only once to the client (when the server code explicitly sets serverState.userId)
        // serverState.runId <= serverSession.runId ? NEVER (ERASED), because it's always communicated in the opposite way (client => server)
        serverState = StateAccessor.setRunId(serverState, null, true);
        if (userIdChanged || sessionIdSyncedChanged)
            storeServerSession(serverSession);
        return serverState;
    }

}
